<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>MakeGames</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

        <link rel="alternate" type="application/rss+xml" title="MakeGames" href="/feed.xml">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">MakeGames</a></h1>
            <h2 class="description">Words and more from Stephen "Schtee" Taylor</h2>
          </div>

          <div class="posts">
   
      <h2><a href="/2014/01/27/json-is-driving-my-new-game.html">JSON Is Driving My New Game</a></h2>
      <p class="meta">27 Jan 2014</p>
      <div class="post">
         <p>I&#39;ve begun work on a game idea that&#39;s been bouncing off the inside wall of my brain for a couple of years now. I&#39;m (obviously) convinced it&#39;s going to be the greatest thing that&#39;s ever been achieved by any being so I won&#39;t go into any gameplay details until I actually have something to show of it. There&#39;s going to be a lot of systemsy stuff in it, so I&#39;ve implemented an <a href="http://en.wikipedia.org/wiki/Entity_component_system">entity/component system (or ECS)</a> in <a href="http://haxe.org/">Haxe</a>. This enables me to write my code in terms of <code>Entities</code>, <code>Components</code> and <code>Systems</code>. My Entities are (more or less) a collection of Components. My Systems register interest with combinations of Components so that they can be notified when a relevant Entity becomes active and can then manipulate is as appropriate. For example my <code>TouchSystem</code> is interested in Entities that have a <code>TouchableComponent</code> and a <code>SpriteComponent</code> (so they know how big the touchable area for the entity is).<br>
One interesting outcome of this approach is it keeps the data very separate from the functionality - Components are just dumb data holders, while the Systems provide the functionality, based on Component composition. I had a plan about how I could leverage this...</p>

<p>I&#39;ve used Unity quite a bit, both professionally and for-funsies, and really appreciate its editor. It gives you the ability to build entities out of components with a drag and drop interface, the effects of which can be seen before you very eyes over in the live-updating 3D views. While I have no intention of writing a full editor for my game I wanted to achieve some degree of development, beyond just level editing, without having to touch the code. I&#39;m using <a href="https://github.com/Kasoki/openfl-tiled">OpenFLTiled</a> to allow me to import <a href="http://www.mapeditor.org">Tiled</a> maps into my game. Tiled also lets you add arbitrary string to string key-value data to the map and its objects. My plan was this: store the types of components, and their initial data, right there in the map.<br>
I implemented a step in the loading of the level that will iterate through the objects in the map and get hold of all the data they store. For each object I spawn an entity. For each key-value pair I use the key as a string representation of a type of component (literally its class name). The value is interpreted as a JSON array, and I get back a bunch of values. Haxe has extensive <a href="http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29">reflection</a> support, so I instantiate the component based on its class name, and pass the deserialised JSON array along to the constructor to build the component just from data stored in the Tiled map. In the map&#39;s data (as opposed to the objects in it) I specify a list of Systems to instantiate for this map (so we could turn off the Physics system for specific maps, for example). So now we can build unique combinations of Components right in Tiled. This is the main advantage ECS has over OO: we don&#39;t have to extend anything to add functionality - it&#39;s all based on run time composition. We can then specify which Systems we want to exist, save it and run the game. Once I have a good library of Components and Systems implemented I can see this leading to a very Unity-like(-a-bit), editor driven workflow for Super Secret Game X.</p>

      </div>
   
      <h2><a href="/2014/01/27/on-posting.html">On Posting</a></h2>
      <p class="meta">27 Jan 2014</p>
      <div class="post">
         <p>I often think about writing more on this here internet, but quickly dismiss the idea, thinking that what’s on my mind is trivial and obvious and of use to no one. Lately I’ve been considering the type of people who would actually read any of the content I’m ever likely to post and my opinion has changed: if you’re reading this you might find stuff I’m implementing in my projects new, interesting or at least vaguely applicable. It doesn’t have to be ground breaking and it might just inspire someone to try a different approach to their development.
With that in mind I’m going to endeavour to post more, starting with the thing that will follow shortly!</p>

      </div>
   
      <h2><a href="/2013/08/08/dirty-haxe.html">Dirty Haxe</a></h2>
      <p class="meta">08 Aug 2013</p>
      <div class="post">
         <p>I&#39;m working on my first ever <a href="http://www.haxe.org">Haxe</a> project and I am loving it. Haxe is a free, open source, object-oriented, cross platform, multi-target, ActionScript-like language and compiler. From one project you can generate:
* a compiled SWF, with support for a bunch of Flash versions
* JavaScript
* PHP
* C#, for targeting Windows,Windows Phone, Xbox or anything Mono supports
* Java, for targeting Android or anything that runs the JVM
* C++, for targeting basically anything else</p>

<p>Apart from SWF these will all provide source code which can then be built in an environment of your choosing.</p>

<h2>What about making games?</h2>

<p>For me, the real magic comes with the OpenFL library - an open source, cross platform implementation of the Flash standard library. This gives you access to a complete, well documented node based view hierarchy that can target basically anything. From the same project, using a different build argument, OpenFL can build to run in browser using HTML5 or Flash; natively on Windows, Mac and Linux desktop; on mobile, with support for iOS, Android and BlackBerry. This means you can hedge your bets when targeting browser: don&#39;t want to worry about flakey HTML5 support? Provide it as an option, but also build a SWF for everybody else. There&#39;s always going to be discrepancy between hardware and screen resolutions available on different mobile devices, but that doesn&#39;t mean you need different code. Build support for different resolutions into your game and target standard hardware features and your game can run on anything.</p>

<h2>The language</h2>

<p>So it can build a game to run on your toaster, but how is it to actually use? Well, for a start it has a compiler, so you know ahead of execution that your local variable is being used without being assigned. It&#39;s strictly typed, so that same compiler can catch you assigning a String to an Int. It also makes good use of type inference so you still don&#39;t have to be too verbose with assignment. It supports generics for some sweet strictly-typed containers. It supports anonymous functions and function objects for super-convenient callbacks. It&#39;s got a thorough standard library with support for sockets, web requests, XML parsing, functional-style set manipulation and a bunch more. The standard library support varies depending on what&#39;s actually available on different platforms, but that&#39;s all covered in the <a href="http://api.haxe.org/">API docs</a>. I haven&#39;t had to touch too much of it for the project I&#39;ve been working on, but the hash map implementation has served me well. Compile times are an oft-quoted boon of Haxe, and from my limited experience it seems great. My MacBook Air generates the JS target for my simple puzzle games in 2-3 seconds.</p>

<p>I&#39;ve struggled a little bit with debugging but that&#39;s mainly a result of targeting HTML5. The JavaScript debugger in Firefox is great but you&#39;re debugging a single monolithic JS file which is a different representation of your Haxe code, and then figuring out what  that actually translates to. I&#39;ll have to explore further if there&#39;s a way to debug something closer to the actual game code I wrote, ideally the Haxe code itself. Declarations are ECMAScript style, <code>name:Type</code> (e.g. <code>var x:Int</code>), which I find a little off-putting as I spend most of my time in C-like languages, but I can cope!</p>

<h2>Conclusion</h2>

<p>I use <a href="http://www.unity3d.com">Unity</a> extensively, both at work and at home, and it&#39;s perfect for making cross-platform 3D games, making heavy use of the concept of scenes. I&#39;ve made a few 2D games in Unity and it always feels like I&#39;m fighting against it, shoehorning 2D elements into a 3D workflow. Haxe with OpenFL seems like a great code-centric alternative to Unity - you get all the benefits of write-once, deploy anywhere, plus the whole Flash standard library to drive your game&#39;s sprites. I&#39;ll definitely be using it for any small 2D games I make in the near future. Also having the option of targeting Flash is a nice bonus few other cross platform solutions still support!</p>

      </div>
   
      <h2><a href="/2013/02/18/events-are-operational.html">Events Are Operational</a></h2>
      <p class="meta">18 Feb 2013</p>
      <div class="post">
         <p>I have implemented my proposal outlined in the previous post and all it&#39;s working great. There&#39;s a base TriggerComponent class which holds a pointer to its action. PositionTriggerComponent extends TriggerComponent, and PositionTriggerSubSystem checks for objects occupying PositionTriggerComponent-Entities&#39; tiles and sets the triggered flag on their Actions. Finally, classes inheriting from ActionSubsystem decide how to handle their actions being triggered. This is working for a simple DebugActionComponent/SubSystem but the idea should apply to anything else. Getting closer to being able to make a game.</p>

      </div>
   
      <h2><a href="/2013/02/11/hello-the-internets.html">Hello, The Internets</a></h2>
      <p class="meta">11 Feb 2013</p>
      <div class="post">
         <p>I&#39;m currently developing a personal-project mobile game using <a href="http://www.cocos2d-x.org">Cocos2d-x</a>, a cross platform port of the Cocos2d-iOS framework. I got as far as having a few graphical layers moving sprites on the screen when I got tired of 2d-x&#39;s weird Objective-C–shoehorned–into–C++ style, which encourages the use of static factory functions to create objects, when C++ already has constructors. I had also been reading a lot about Entity/Component (EC) systems for game development – a methodology that allows for game objects to be built up from collections of reusable components, and, relevantly, forces logic to be separated from display code. I thought this would be a great opportunity to implement my own EC system, as it would keep the nasty Object-C style code very localised and wouldn&#39;t spread to any parts of the game logic.</p>

<p>This went really well – after writing and refining the EC framework, then coding some fundamental components and subsystems (such as SpriteRenderable and Position components and SpriteRenderer subsystem), I had a character I could set the world position of, and the SpriteRenderer subsystem would set the Cocos sprite&#39;s position accordingly. I went on to write the relevant components and subsystems to get the character moving around a tile base map, using the Cocos touch interface and all was good.</p>

<p>Then I hit a problem. The game I&#39;m developing needs a trigger system. An entity (e.g. a button) needs to trigger an action (e.g. a door opening). This requires the subsystem to track entities with Button components (the trigger) and entities with Position components (the entity that will cause the button to trigger) and consider them independently:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">for each Entity with Button and Position: b
    for each Entity with Position: p
        if b.pos == p.pos
            b.button.triggerAction()
</code></pre></div>
<p>..which my current system doesn&#39;t support, so I&#39;ll have to add the concept of <em>or</em> and <em>and</em> operators to the class that defines the types a subsystem is interested in. I&#39;ll check back in when that&#39;s implemented and hopefully I&#39;ll have a nice, flexible event triggering system.</p>

      </div>
   

   
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Stephen <a href="http://www.twitter.com/schtee">"Schtee"</a> Taylor
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
