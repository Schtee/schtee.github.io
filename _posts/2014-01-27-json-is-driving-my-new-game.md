---
title: JSON Is Driving My New Game
layout: post
date: 2014-01-27 00:00:01
---
I've begun work on a game idea that's been bouncing off the inside wall of my brain for a couple of years now. I'm (obviously) convinced it's going to be the greatest thing that's ever been achieved by any being so I won't go into any gameplay details until I actually have something to show of it. There's going to be a lot of systemsy stuff in it, so I've implemented an [entity/component system (or ECS)](http://en.wikipedia.org/wiki/Entity_component_system) in [Haxe](http://haxe.org/). This enables me to write my code in terms of `Entities`, `Components` and `Systems`. My Entities are (more or less) a collection of Components. My Systems register interest with combinations of Components so that they can be notified when a relevant Entity becomes active and can then manipulate is as appropriate. For example my `TouchSystem` is interested in Entities that have a `TouchableComponent` and a `SpriteComponent` (so they know how big the touchable area for the entity is).  
One interesting outcome of this approach is it keeps the data very separate from the functionality - Components are just dumb data holders, while the Systems provide the functionality, based on Component composition. I had a plan about how I could leverage this...

I've used Unity quite a bit, both professionally and for-funsies, and really appreciate its editor. It gives you the ability to build entities out of components with a drag and drop interface, the effects of which can be seen before you very eyes over in the live-updating 3D views. While I have no intention of writing a full editor for my game I wanted to achieve some degree of development, beyond just level editing, without having to touch the code. I'm using [OpenFLTiled](https://github.com/Kasoki/openfl-tiled) to allow me to import [Tiled](http://www.mapeditor.org) maps into my game. Tiled also lets you add arbitrary string to string key-value data to the map and its objects. My plan was this: store the types of components, and their initial data, right there in the map.  
I implemented a step in the loading of the level that will iterate through the objects in the map and get hold of all the data they store. For each object I spawn an entity. For each key-value pair I use the key as a string representation of a type of component (literally its class name). The value is interpreted as a JSON array, and I get back a bunch of values. Haxe has extensive [reflection](http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29) support, so I instantiate the component based on its class name, and pass the deserialised JSON array along to the constructor to build the component just from data stored in the Tiled map. In the map's data (as opposed to the objects in it) I specify a list of Systems to instantiate for this map (so we could turn off the Physics system for specific maps, for example). So now we can build unique combinations of Components right in Tiled. This is the main advantage ECS has over OO: we don't have to extend anything to add functionality - it's all based on run time composition. We can then specify which Systems we want to exist, save it and run the game. Once I have a good library of Components and Systems implemented I can see this leading to a very Unity-like(-a-bit), editor driven workflow for Super Secret Game X.
